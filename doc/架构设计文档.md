# AI Teacher 架构设计文档

## 📋 项目概述

AI Teacher 是一个基于多智能体系统的AI教学助手，采用MCP（Model Context Protocol）协议实现工具调用机制。项目使用Kotlin开发，支持Android平台。

## 🏗️ 整体架构

### 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        AI Teacher 系统                          │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │SecretaryAgent│  │TeachingAgent│  │StudentAgent │             │
│  │   (教秘)    │  │   (教学)    │  │   (学生)    │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│         │                 │                 │                   │
│         └─────────────────┼─────────────────┘                   │
│                           │                                     │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                    BaseAgent (MCP Host)                    │ │
│  │  ┌─────────────────────────────────────────────────────────┐│ │
│  │  │                MCPHost (Client集合)                     ││ │
│  │  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     ││ │
│  │  │  │MCP Client 1 │  │MCP Client 2 │  │MCP Client N │     ││ │
│  │  │  │(1:1连接)   │  │(1:1连接)   │  │(1:1连接)   │     ││ │
│  │  │  └─────────────┘  └─────────────┘  └─────────────┘     ││ │
│  │  └─────────────────────────────────────────────────────────┘│ │
│  └─────────────────────────────────────────────────────────────┘ │
│                           │                                     │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                MCPServerRegistry (单例)                     │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │ │
│  │  │KnowledgeSrv │  │AnalysisSrv  │  │QuestionSrv  │         │ │
│  │  │(知识库)     │  │(学习分析)   │  │(题目生成)   │         │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘         │ │
│  └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 核心组件

### 1. Agent层

#### BaseAgent (抽象基类)
- **职责**: 所有智能体的基础类，实现MCP Host功能
- **核心功能**:
  - 管理对话上下文和记忆
  - 调用LLM模型进行推理
  - 解析和执行工具调用
  - 维护MCP Host连接

```kotlin
abstract class BaseAgent(
    val name: String,
    description: String? = null,
    protected val model: LLMModel = LLMModel("qwen-max"),
    availableTools: List<String> = emptyList(),
    memory: ContextMemory = UserManager().getCurrentUserMemory() ?: ContextMemory(maxMemorySize = 20),
    maxToolIterations: Int = 3
) {
    // MCP Host - 每个Agent维护自己的Client集合
    private val mcpHost = MCPHost(name, availableTools)
}
```

#### 具体Agent实现
- **SecretaryAgent**: 教秘代理，负责制定教学计划
- **TeachingAgent**: 教学代理，负责具体教学实施
- **StudentAgent**: 学生代理，负责学习辅导

### 2. MCP层

#### MCPHost (Client集合管理器)
- **职责**: 管理Agent的所有MCP Client连接
- **核心特性**:
  - 一个Client对应一个Server (1:1关系)
  - 根据工具名称路由到对应的Client
  - 聚合所有Client的工具列表
  - 管理连接生命周期

```kotlin
class MCPHost(
    private val hostName: String,
    private val requiredTools: List<String>
) {
    private val clients = mutableMapOf<String, Client>() // serverId -> Client
    private val toolToServerMap = mutableMapOf<String, String>() // toolName -> serverId
}
```

#### MCPServerRegistry (服务器注册表)
- **职责**: 管理所有可用的MCP Server信息
- **功能**:
  - 注册和发现MCP Server
  - 根据工具名称查找对应的服务器
  - 管理服务器配置信息

### 3. 服务层

#### LLMModel (大语言模型)
- **职责**: 提供AI推理能力
- **功能**:
  - 文本生成
  - 工具调用解析
  - 对话上下文管理

#### ContextMemory (上下文记忆)
- **职责**: 管理对话历史和上下文
- **功能**:
  - 存储对话记录
  - 检索相关历史
  - 管理记忆容量

## 🔄 工作流程

### 1. Agent初始化流程

```
1. Agent实例化
   ├── 定义availableTools: ["knowledge_base", "analyze_progress"]
   ├── 创建MCPHost(hostName, availableTools)
   ├── MCPHost查询MCPServerRegistry
   ├── 为每个工具找到对应的Server
   ├── 为每个Server创建对应的Client (1:1关系)
   ├── 建立toolToServerMap映射
   └── 将工具规范注册到LLMModel
```

### 2. 用户交互流程

```
1. 用户输入
   ├── Agent.runOnce(userInput)
   ├── 记录用户输入到ContextMemory
   ├── 构建prompt (包含工具信息和历史上下文)
   ├── LLMModel.generateText(prompt)
   └── 解析LLM输出

2. 工具调用处理
   ├── 检查是否需要工具调用
   ├── 解析工具名称和参数
   ├── Agent.callTool(toolName, parameters)
   ├── MCPHost.callTool(toolName, parameters)
   ├── 根据toolToServerMap找到对应的Client
   ├── Client.callTool(toolName, parameters)
   └── MCPServer执行工具逻辑

3. 结果处理
   ├── MCPServer返回结果
   ├── Client返回结果
   ├── MCPHost返回结果
   ├── Agent处理结果并更新ContextMemory
   └── 返回最终响应给用户
```

## 🛠️ MCP协议实现

### 协议约定

1. **一个MCP Client只能维持与一个Server的1:1会话**
2. **Host侧可以new多个Client来连接多个Server**
3. **Host负责聚合多个Client的工具列表**
4. **Host根据工具名称决定调用哪个Client**

### 传输方式支持

- **stdio**: 标准输入输出，用于本地进程通信
- **websocket**: WebSocket连接，用于网络通信
- **sse**: Server-Sent Events，用于单向数据流

### 工具注册机制

```kotlin
// 服务器注册
MCPServerRegistry.registerServer("knowledge_server", MCPServerInfo(
    serverId = "knowledge_server",
    name = "知识库服务器",
    availableTools = listOf("knowledge_base"),
    transportType = "stdio",
    connectionInfo = mapOf("command" to "java -jar knowledge-server.jar")
))

// Agent使用工具
class SecretaryAgent : BaseAgent(
    name = "SecretaryAgent",
    availableTools = listOf("knowledge_base") // 只允许使用知识库工具
)
```

## 📊 数据模型

### 核心数据类

#### Student (学生信息)
```kotlin
data class Student(
    val id: String,
    val name: String,
    val grade: Int,
    val subject: String,
    val learningLevel: LearningLevel,
    val progress: Map<String, Any>
)
```

#### LearningLevel (学习水平)
```kotlin
enum class LearningLevel {
    BEGINNER,    // 初学者
    INTERMEDIATE, // 中级
    ADVANCED     // 高级
}
```

#### MemoryEntry (记忆条目)
```kotlin
data class MemoryEntry(
    val id: String,
    val content: Map<String, String>,
    val timestamp: Date = Date(),
    val metadata: Map<String, Any> = emptyMap()
)
```

## 🔒 安全与权限

### 工具权限控制
- 每个Agent只能使用预定义的工具列表
- 工具调用需要验证Agent权限
- 敏感操作需要额外授权

### 数据隔离
- 每个用户有独立的ContextMemory
- Agent之间数据隔离
- 支持多用户并发访问

## 🚀 扩展性设计

### 新增Agent
1. 继承BaseAgent类
2. 定义availableTools列表
3. 实现特定的业务逻辑

### 新增工具
1. 在MCPServerRegistry中注册新的Server
2. 实现MCPServer提供工具服务
3. Agent通过availableTools参数使用新工具

### 新增传输方式
1. 在MCPHost中添加新的传输类型支持
2. 实现对应的Transport类
3. 更新服务器配置

## 📈 性能优化

### 连接管理
- Client连接复用，避免重复连接
- 连接池管理，控制并发连接数
- 自动重连机制，保证服务可用性

### 内存管理
- ContextMemory容量限制，避免内存溢出
- 定期清理过期记忆
- 智能记忆压缩算法

### 异步处理
- 所有I/O操作使用协程异步处理
- 工具调用并行执行
- 非阻塞的Agent运行循环

## 🔧 开发指南

### 环境要求
- Kotlin 1.9+
- Android SDK 24+
- Gradle 8.0+

### 项目结构
```
app/src/main/java/com/aiteacher/
├── ai/
│   ├── agent/           # Agent实现
│   ├── mcp/            # MCP协议实现
│   │   ├── client/     # MCP Client
│   │   ├── server/     # MCP Server
│   │   └── registry/   # 服务器注册表
│   └── service/        # 服务层
├── domain/
│   └── model/          # 数据模型
└── ui/                 # UI层
```

### 运行方式
1. 启动MCP Server进程
2. 注册服务器到MCPServerRegistry
3. 创建Agent实例
4. 调用Agent.runOnce()处理用户输入

## 📝 总结

本架构设计严格遵循MCP协议约定，实现了：

1. **协议合规**: 一个Client对应一个Server的1:1关系
2. **资源隔离**: 每个Agent维护自己的Client集合
3. **灵活扩展**: 支持动态添加Agent和工具
4. **高性能**: 异步处理和连接复用
5. **易维护**: 清晰的模块划分和职责分离

该架构为AI Teacher系统提供了稳定、可扩展的基础，支持复杂的多智能体协作场景。
