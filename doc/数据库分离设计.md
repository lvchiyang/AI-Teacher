# 数据库分离设计

## 概述

为了更好地组织和管理数据，我们将原来单一的数据库拆分为四个独立的数据库，每个数据库负责特定类型的数据存储。这种设计遵循了单一职责原则，使系统更加模块化和易于维护。

## 数据库结构

### 1. 学生数据库 (AITeacherDatabase)
- **数据库文件名**: ai_teacher_database
- **负责实体**: StudentEntity
- **主要功能**: 存储学生基本信息

### 2. 用户数据库 (UserDatabase)
- **数据库文件名**: user_database
- **负责实体**: UserEntity
- **主要功能**: 存储用户信息（家长和学生）

### 3. 知识数据库 (KnowledgeDatabase)
- **数据库文件名**: knowledge_database
- **负责实体**: KnowledgeEntity
- **主要功能**: 存储知识点信息

### 4. 题目数据库 (QuestionDatabase)
- **数据库文件名**: question_database
- **负责实体**: QuestionEntity
- **主要功能**: 存储题目信息

## 设计优势

### 1. 数据隔离
不同类型的數據存储在不同的数据库中，避免了数据混乱，提高了数据安全性。

### 2. 性能优化
每个数据库只处理特定类型的数据，减少了单个数据库的负载，提高了查询和写入性能。

### 3. 易于维护
当需要修改某一类数据的结构时，只需关注对应的数据库，不会影响其他数据。

### 4. 扩展性好
可以根据业务需求独立扩展某个数据库，而不需要重构整个数据存储系统。

## 实现细节

### 数据库类
每个数据库都有独立的数据库类，继承自RoomDatabase，并包含相应的DAO抽象方法。

### Application类更新
AITeacherApplication类现在管理四个独立的数据库实例，每个实例通过懒加载方式初始化。

### 测试更新
所有测试类都已更新为使用对应的独立数据库实例，确保测试的准确性和独立性。

## 使用示例

```kotlin
// 获取用户数据库实例
val userDatabase = UserDatabase.getDatabase(context)
val userRepository = UserRepository(userDatabase.userDao())

// 获取知识数据库实例
val knowledgeDatabase = KnowledgeDatabase.getDatabase(context)
val knowledgeRepository = KnowledgeRepository(knowledgeDatabase.knowledgeDao())

// 获取题目数据库实例
val questionDatabase = QuestionDatabase.getDatabase(context)
val questionRepository = QuestionRepository(questionDatabase.questionDao())
```

## 注意事项

1. 每个数据库都有独立的文件存储，因此需要注意存储空间的使用
2. 跨数据库的事务操作需要特别处理
3. 数据库版本管理需要分别进行