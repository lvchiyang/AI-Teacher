在 Compose 里，“不同 UI 界面跳转” 仍然靠 **NavController**；  
ViewModel 只负责 **“告诉界面该走了”**，  
界面（Composable）收到信号后，**真正调用** `navController.navigate("目标路由")`。

------------------------------------------------
一句话流程
------------------------------------------------
ViewModel 发**事件** → View 观察事件 → View 拿 NavController 做跳转。

------------------------------------------------
最小完整示例（双页面）
------------------------------------------------
需求：  
- 页面 A（登录页）输入姓名 → 点“登录” → 页面 B（首页）显示欢迎语。

1. 路由表（纯字符串，全局可用）

```kotlin
object Routes {
    const val LOGIN = "login"
    const val HOME  = "home/{user}"   // 带参数
}
```

2. 总舞台（仅一次定义）

```kotlin
// 使用@Composable注解，表示这是一个可组合函数，用于构建UI
@Composable
// 定义AppNav函数，这是应用的主要导航组件
fun AppNav() {
    // 创建并记住导航控制器，用于管理页面间的导航
    val navController = rememberNavController()
    // 创建导航主机，设置起始页面为登录页面
    NavHost(navController, startDestination = Routes.LOGIN) {
        // 定义登录页面的路由配置
        composable(Routes.LOGIN) {
            // 显示登录界面，并设置登录成功后的回调函数，onLoginOk是一个函数名，定义了这样一个函数！。
            LoginScreen(onLoginOk = { user ->
                // 登录成功后，导航到主页，并传递用户信息作为参数
                navController.navigate("home/$user")   // 真正跳转
            })
        }
        // 定义主页面的路由配置，支持动态参数
        composable(Routes.HOME) { backStack ->
            // 从导航参数中获取用户信息，如果获取失败则使用空字符串
            val user = backStack.arguments?.getString("user") ?: ""
            // 显示主页面，传递用户信息和返回按钮的回调函数
            HomeScreen(user = user, onBack = { navController.popBackStack() })
        }
    }
}
```

3. 页面 A（LoginScreen）

```kotlin
// 使用@Composable注解，表示这是一个可组合函数，用于构建UI界面
@Composable
// 定义LoginScreen函数，接收登录成功回调函数和ViewModel实例
fun LoginScreen(onLoginOk: (String) -> Unit, vm: LoginVM = viewModel()) {
    // 使用collectAsState()监听ViewModel中user状态的变化，实现响应式UI更新
    val user by vm.user.collectAsState()
    // 检查ViewModel中的jump标志，判断是否需要触发页面跳转
    if (vm.jump) {
        // 关键：在副作用中一次性触发跳转，避免重复调用
        // LaunchedEffect确保跳转逻辑只在组合时执行一次
        LaunchedEffect(Unit) { onLoginOk(user) }
    }

    // 创建垂直布局容器，填充整个屏幕并在垂直方向居中排列
    // Modifier.fillMaxSize(): 修饰符，让Column填充父容器的最大可用空间（宽度和高度）
    // verticalArrangement = Arrangement.Center: 垂直排列方式，将子组件在垂直方向上居中对齐
    Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center) {
        // 创建带边框的文本输入框，用于输入用户名
        // value: 绑定到user状态，显示当前输入内容
        // onValueChange: 当用户输入时，更新ViewModel中的user值，在是OutlinedTextField的设置方法
        // label: 显示输入框的标签文本
        OutlinedTextField(value = user, onValueChange = { vm.user.value = it }, label = { Text("姓名") })
        // 创建登录按钮，点击时调用ViewModel的login方法
        Button(onClick = { vm.login() }) { Text("登录") }
    }
}
```

4. ViewModel（LoginVM）

```kotlin
// 定义LoginVM类，继承自ViewModel，用于管理登录页面的状态和业务逻辑
class LoginVM : ViewModel() {
    // 创建可变的用户名字段，初始值为空字符串
    // mutableStateOf创建响应式状态，UI会自动响应状态变化
    val user = mutableStateOf("")
    // 创建跳转标志字段，使用by委托语法
    // private set表示外部不能直接修改jump的值，只能通过类内部方法修改
    var jump by mutableStateOf(false)
        private set

    // 定义登录方法，处理登录逻辑
    fun login() {
        // 检查用户名是否不为空（去除空白字符后）
        // 如果用户名有效，则设置jump为true，触发页面跳转
        if (user.value.isNotBlank()) jump = true   // 只发"暗号"
    }
}
```

5. 页面 B（HomeScreen）

```kotlin
// 使用@Composable注解，表示这是一个可组合函数，用于构建主页面UI
@Composable
// 定义HomeScreen函数，接收用户名和返回按钮的回调函数
fun HomeScreen(user: String, onBack: () -> Unit) {
    // 创建垂直布局容器，填充整个屏幕并在垂直方向居中排列
    Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center) {
        // 显示欢迎文本，使用字符串模板插入用户名
        // style参数使用Material Design的主题样式，设置为中等标题样式
        Text("欢迎，$user！", style = MaterialTheme.typography.headlineMedium)
        // 创建返回按钮，点击时调用onBack回调函数
        Button(onClick = onBack) { Text("返回") }
    }
}
```

------------------------------------------------
交互链再梳理（详细流程分析）
------------------------------------------------
1. 用户点"登录" → 调用 `vm.login()`  
   // 用户在UI上点击登录按钮，触发Button的onClick事件

2. VM 把 `jump = true`（事件）  
   // ViewModel执行login()方法，检查用户名有效性后设置跳转标志

3. `LoginScreen` 观察到 `jump` → `LaunchedEffect` 里执行 `onLoginOk(user)`  
   // UI通过collectAsState()监听到jump状态变化，触发LaunchedEffect副作用

4. `onLoginOk` 由 NavHost 传入，内部就是 `navController.navigate("home/xxx")`  
   // 回调函数由导航主机提供，实际执行页面跳转指令

5. NavController 卸掉 `LoginScreen`，装上 `HomeScreen`  
   // 导航控制器管理页面栈，移除当前页面，加载目标页面

------------------------------------------------
架构设计原则（重要结论）
------------------------------------------------
- **ViewModel 绝不碰 NavController**；  
  // ViewModel只负责业务逻辑和状态管理，不直接操作导航

- **Composable 自己拿 NavController 做跳转**；  
  // UI组件负责处理导航逻辑，保持职责分离

- 数据（`jump`/`user`）只是 ViewModel 与 View 之间的"暗号"。  
  // 通过状态变化实现组件间通信，避免直接依赖