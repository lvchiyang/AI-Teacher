在 Compose 里，“不同 UI 界面跳转” 仍然靠 **NavController**；  
ViewModel 只负责 **“告诉界面该走了”**，  
界面（Composable）收到信号后，**真正调用** `navController.navigate("目标路由")`。

------------------------------------------------
一句话流程
------------------------------------------------
ViewModel 发**事件** → View 观察事件 → View 拿 NavController 做跳转。

------------------------------------------------
最小完整示例（双页面）
------------------------------------------------
需求：  
- 页面 A（登录页）输入姓名 → 点“登录” → 页面 B（首页）显示欢迎语。

1. 路由表（纯字符串，全局可用）

```kotlin
object Routes {
    const val LOGIN = "login"
    const val HOME  = "home/{user}"   // 带参数
}
```

2. 总舞台（仅一次定义）

```kotlin
// 使用@Composable注解，表示这是一个可组合函数，用于构建UI
@Composable
// 定义AppNav函数，这是应用的主要导航组件
fun AppNav() {
    // 创建并记住导航控制器，用于管理页面间的导航
    val navController = rememberNavController()
    // 创建导航主机，设置起始页面为登录页面
    NavHost(navController, startDestination = Routes.LOGIN) {
        // 定义登录页面的路由配置
        composable(Routes.LOGIN) {
            // 显示登录界面，并设置登录成功后的回调函数，onLoginOk是一个函数名，定义了这样一个函数！。
            LoginScreen(onLoginOk = { user ->
                // 登录成功后，导航到主页，并传递用户信息作为参数
                navController.navigate("home/$user")   // 真正跳转
            })
        }
        // 定义主页面的路由配置，支持动态参数
        composable(Routes.HOME) { backStack ->
            // 从导航参数中获取用户信息，如果获取失败则使用空字符串
            val user = backStack.arguments?.getString("user") ?: ""
            // 显示主页面，传递用户信息和返回按钮的回调函数
            HomeScreen(user = user, onBack = { navController.popBackStack() })
        }
    }
}
```

3. 页面 A（LoginScreen）

```kotlin
@Composable
fun LoginScreen(onLoginOk: (String) -> Unit, vm: LoginVM = viewModel()) {
    val user by vm.user.collectAsState()
    if (vm.jump) {
        // 关键：副作用里一次性触发跳转
        LaunchedEffect(Unit) { onLoginOk(user) }
    }

    Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center) {
        OutlinedTextField(value = user, onValueChange = { vm.user.value = it }, label = { Text("姓名") })
        Button(onClick = { vm.login() }) { Text("登录") }
    }
}
```

4. ViewModel（LoginVM）

```kotlin
class LoginVM : ViewModel() {
    val user = mutableStateOf("")
    var jump by mutableStateOf(false)
        private set

    fun login() {
        if (user.value.isNotBlank()) jump = true   // 只发“暗号”
    }
}
```

5. 页面 B（HomeScreen）

```kotlin
@Composable
fun HomeScreen(user: String, onBack: () -> Unit) {
    Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center) {
        Text("欢迎，$user！", style = MaterialTheme.typography.headlineMedium)
        Button(onClick = onBack) { Text("返回") }
    }
}
```

------------------------------------------------
交互链再梳理
------------------------------------------------
1. 用户点“登录” → 调用 `vm.login()`  
2. VM 把 `jump = true`（事件）  
3. `LoginScreen` 观察到 `jump` → `LaunchedEffect` 里执行 `onLoginOk(user)`  
4. `onLoginOk` 由 NavHost 传入，内部就是 `navController.navigate("home/xxx")`  
5. NavController 卸掉 `LoginScreen`，装上 `HomeScreen`  

------------------------------------------------
结论
------------------------------------------------
- **ViewModel 绝不碰 NavController**；  
- **Composable 自己拿 NavController 做跳转**；  
- 数据（`jump`/`user`）只是 ViewModel 与 View 之间的“暗号”。