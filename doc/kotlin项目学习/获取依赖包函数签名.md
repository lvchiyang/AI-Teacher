下面给出一条“从零开始 → 拿到依赖里所有函数签名 → 快速拼出最小可用代码”的完整操作流程。  
全程只依赖官方/开源工具，不反编译源码也能跑通；如果你想更进一步，文末也给出“反编译补丁”一步，按需取用即可。

------------------------------------------------
一、前置准备（一次性）
1. 新建一个空 Kotlin 工程（Gradle Kotlin DSL 最方便）。  
2. 把你要研究的依赖扔进来，并一次性把“扫包 + 反射”三件套装齐：  
   ```kotlin
   // build.gradle.kts
   dependencies {
       implementation("com.example:unknown-lib:1.0.0")   // ① 目标依赖
       implementation("org.jetbrains.kotlin:kotlin-reflect") // ② Kotlin 反射
       implementation("io.github.classgraph:classgraph:4.8.174") // ③ 扫整个 jar
   }
   ```

------------------------------------------------
二、一次性打印“整个依赖的公开 API 清单”
把下面文件直接粘进 `src/main/kotlin/ApiDump.kt` 然后运行 `Run > ApiDumpKt`。  
运行完会在项目根目录得到 `api.txt`，它就是你要的“所有函数签名”。

```kotlin
import io.github.classgraph.ClassGraph
import kotlin.reflect.KClass
import kotlin.reflect.full.*
import java.io.File

fun main() {
    File("api.txt").bufferedWriter().use { out ->
        ClassGraph()
            .acceptPackages("com.example")   // ① 改成依赖的包名前缀
            .enableAllInfo()
            .scan().use { scan ->
                scan.allClasses
                    .filter { it.isPublic }
                    .map { it.loadClass().kotlin }
                    .forEach { kcls -> dump(kcls, out) }
            }
    }
    println("✅ 完成，共输出 ${File("api.txt").readLines().size} 行")
}

private fun dump(kcls: KClass<*>, out: java.io.BufferedWriter) {
    out.appendLine("### ${kcls.qualifiedName}")
    // 1. 构造函数
    kcls.constructors.forEach { out.appendLine("  ctor  $it") }
    // 2. 静态/伴生函数
    kcls.staticFunctions.forEach { out.appendLine("  static $it") }
    // 3. 成员函数（含扩展）
    kcls.declaredFunctions.forEach { out.appendLine("  fun    $it") }
    // 4. 公开属性
    kcls.declaredMemberProperties.forEach { out.appendLine("  val/var $it") }
    out.appendLine("")
}
```

------------------------------------------------
三、用“API 清单”快速定位入口
1. 打开 `api.txt`，先全局搜关键词：  
   `Builder`, `Factory`, `create`, `default`, `Impl`, `entry`, `main`, `init`  
   这些名字里 80% 是作者留给你的“入口类/入口函数”。  
2. 再把所有 `suspend fun` 和带 `Callback` 参数的函数单独拎出来，  
   它们几乎一定对应“异步调用”，先记住，后面写代码时再决定是不是要 `runBlocking {}` 或者传 lambda。  
3. 如果看到 `enum class Xxx`，把它的 `valueOf`/`values` 也记下——  
   后面传参时经常要拿枚举值，但反射看不到具体枚举实例，只能先留空再试跑。

------------------------------------------------
四、根据签名“盲写”一段最小可运行代码
假设你从清单里锁定了一个看起来最像“入口”的类：

```
### com.example.unknownlib.Foo
ctor  fun constructor(config: com.example.unknownlib.Config)
fun   fun start(message: kotlin.String): kotlin.Int
```

就可以立刻写一段“试探”：

```kotlin
import com.example.unknownlib.Config
import com.example.unknownlib.Foo

fun main() {
    val cfg = Config()          // ① 先空参构造，能跑通再说
    val foo = Foo(cfg)          // ② 用构造函数实例化
    val code = foo.start("hi")  // ③ 调核心方法
    println("返回码=$code")
}
```

运行后会有三种结果：  
- 直接跑通 → 恭喜，你已经会用了，剩下的只是读返回码/回调。  
- 抛 `IllegalArgumentException/IllegalStateException` → 把异常消息复制下来，  
  回 `api.txt` 搜相关类型，补参数或换枚举再试。  
- 缺依赖/缺 Dispatcher/缺 Android Context → 按异常提示把缺失的依赖或上下文补进来即可。

------------------------------------------------
五、（可选）反编译再补细节
当签名不够用，例如：  
- 默认值看不见；  
- 接口/抽象类需要知道实现类；  
- 异步回调需要知道线程模型。  

只需两步：  
1. IDEA 里双击类名 → `Decompile`（或 `Ctrl+Shift+N` 打开 `.class` 文件）就能看到 Java 伪代码；  
2. 把伪代码里的 `if/else`、`when`、`Dispatchers.XXX` 等逻辑抄回你的试探代码，  
   基本就能 100% 还原作者意图。

------------------------------------------------
六、总结一句话
“扫包 → 反射打印签名 → 盲写试探 → 运行时异常当文档 → 反编译补细节”  
按上面 5 步流水线，**哪怕依赖完全闭源、没有文档、没有源码**，  
也能在 1～2 小时内拼出最小可用调用链，剩下的就是正常业务编码了。祝你使用愉快！